struct Material
{
    vec3 colour;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
    float shininess;
};

struct Sphere
{
    vec3 centre;
    float radius;
};

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = fragCoord/iResolution.xy;
    float aspectRatio = iResolution.x/iResolution.y;
    uv.x *= aspectRatio;
    
    Sphere sph;
    sph.centre = vec3(0.5, 0.5, 5.0);
    sph.centre.x *= aspectRatio;
    sph.radius = 0.3;
    
    vec3 uv_3D; //PSEUDO 3D version of our original pixel

    //Surface material
    Material sphereMat;
    sphereMat.colour = vec3(1.0, 0.0, 0.0);
    sphereMat.ambient = vec3(0.2, 0.2, 0.2);
    sphereMat.diffuse = vec3(0.5, 0.5, 0.5);
    sphereMat.specular = vec3(0.8, 0.8, 0.8);
    sphereMat.shininess = 64.0;
    
    //Light properties
    vec3 lightColour = vec3(1.0, 1.0, 1.0);
    vec3 lightPosition = vec3(5.0, 5.0, -1.0);
    
    //Camera position
    vec3 cameraPosition = vec3(0.5, 0.5, 0.0);
    
    //Surface normal (TODO)
    vec3 normal = vec3(0.0, 0.0, -1.0);
    //*****
    
    vec3 col = vec3(0.0);
    
    if(length(uv - sph.centre.xy) <= sph.radius)
    {
        //PHONG ALGORITHM

        vec3 ambientComponent = vec3(0.0);
        vec3 diffuseComponent = vec3(0.0);
        vec3 specularComponent = vec3(0.0);

        //Ambient component
        ambientComponent = sphereMat.colour * sphereMat.ambient * lightColour;

        //Diffuse component
        vec3 lightDirection = normalize(lightPosition - uv_3D); 
        float diff = dot(normal, lightDirection);
        //float diff = max(dot(normal, lightDirection), 0.0);
        diffuseComponent = sphereMat.colour * sphereMat.diffuse * lightColour * diff;

        //Specular component
        vec3 reflDirection = reflect(-lightDirection, normal);
        vec3 viewDirection = normalize(cameraPosition - uv_3D);
        //float spec = pow(dot(viewDirection, reflDirection), sphereMat.shininess);
        float spec = pow(max(dot(viewDirection, reflDirection), 0.0), sphereMat.shininess);
        specularComponent = sphereMat.colour * sphereMat.specular * lightColour * spec;

        col = ambientComponent + diffuseComponent + specularComponent;
    }
    
    // Output to screen
    fragColor = vec4(col,1.0);
}